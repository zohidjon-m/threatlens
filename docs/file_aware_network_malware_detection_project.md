# File-Aware Network Malware Detection System
**Big Data Course Project – Detailed Technical Explanation & Clean Architecture**

---

## 1. Project Overview

Modern malware often hides inside files (executables, documents, archives) transferred over standard network protocols such as HTTP, FTP, SMTP, and SMB. Traditional network intrusion detection systems (IDS) focus mainly on packet metadata or signatures, which is not sufficient against modern, polymorphic, and file-based threats.

This project implements a **file-aware network malware detection system** that combines:

- **Network traffic analysis** using Zeek.
- **Big data processing** of network logs using Apache Spark.
- **Static malware detection** using a machine-learning model trained on the EMBER dataset.
- **Threat intelligence integration** (hash reputation from public feeds).
- **Explainable AI (XAI)** using SHAP values for model interpretability.
- **Graph-based network visualization** to show relationships between hosts and malicious activity.
- An interactive **dashboard** that brings all results together.

The system is designed to be **batch-based as the core**, with an optional **real-time streaming extension using Kafka** if time and scope permit.

---

## 2. High-Level Goals

1. **Detect malicious files** traversing the network by classifying extracted files with an ML model.
2. **Identify suspicious network behavior** through large-scale analysis of connection logs.
3. **Correlate file risk and network risk** into a unified threat score per file and per host.
4. **Provide explanations and context** (threat intelligence, SHAP, network graph) so a security analyst can understand *why* an alert was generated.
5. **Demonstrate big data usage** through distributed processing with Spark on large Zeek log datasets.

---

## 3. Core Data Sources

### 3.1 PCAP Traffic Datasets

The system operates on captured network traffic in PCAP format. Suitable datasets include:

- **CIC-IDS 2018** – real and attack traffic with rich HTTP/DNS activity.
- **UNSW-NB15** – synthetic but labeled intrusion dataset.
- **CTU-13** – botnet traffic.
- **MAWI Archive** – real backbone traffic (for volume and realism).

These PCAP files are used as input to **Zeek**, which parses the traffic, reconstructs flows, and extracts files and logs.

### 3.2 EMBER Malware Dataset

For static malware detection, the system uses the **EMBER dataset** (Endgame Malware BEnchmark for Research), which consists of:

- Windows PE files labeled as benign or malicious.
- Pre-extracted static features (e.g., header features, byte histograms, imports).
- A feature vector representation suitable for ML training.

We **do not** need to reverse engineer or execute real malware; we use the pre-extracted features for safe, offline model training.

---

## 4. Log and File Structures

### 4.1 Zeek Logs

Zeek produces structured logs in TSV or JSON formats. Key logs:

#### `conn.log` – Connection Metadata

Fields (simplified):
- `ts`: timestamp
- `uid`: unique connection ID
- `id.orig_h`: source IP
- `id.resp_h`: destination IP
- `id.orig_p`: source port
- `id.resp_p`: destination port
- `proto`: protocol (tcp/udp)
- `service`: inferred application protocol (http, dns, etc.)
- `duration`: connection duration
- `orig_bytes`, `resp_bytes`: bytes sent by each side

#### `http.log` – HTTP Requests/Responses

Fields:
- `uid`: connection ID (join key with `conn.log`)
- `method`: HTTP method (GET, POST, ...)
- `host`: host header
- `uri`: requested path
- `referrer`: referrer header
- `user_agent`: client UA string
- `status_code`: HTTP status

#### `dns.log` – DNS Queries

Fields:
- `uid`: connection ID
- `query`: domain name
- `qtype_name`: query type (A, AAAA, MX, ...)
- `rcode_name`: response code
- `answers`: returned IPs or records

#### `files.log` – File Metadata

Fields:
- `fuid`: file unique ID (key)
- `tx_hosts`: list of transmitter hosts
- `rx_hosts`: list of receiver hosts
- `mime_type`: detected MIME type
- `size`: file size in bytes
- `md5`, `sha1`, `sha256`: (optional, if configured)
- `seen_from`: direction (originator/responder)
- `ts`: timestamp

### 4.2 Extracted Files

When file extraction is enabled, Zeek reconstructs file contents from flows and stores them in a directory such as:

```text
/opt/zeek/logs/<date>/extract_files/EXTRACTED_fuid_<hash>
```

Each file can be linked back to `files.log` using `fuid` and from there to `conn.log` and `http.log` using `uid` and host IPs.

---

## 5. Storage Layer (Database Design)

### 5.1 Choice of Database

**MongoDB** is used as the main operational database because:

- Logs and analysis results are naturally JSON-like.
- Schema evolution is easy during development.
- Querying by host, file hash, or time is straightforward.
- It integrates well with Python and web backends.

### 5.2 Collections and Schemas

#### `files` Collection

Stores metadata for each extracted file:

```json
{
  "fuid": "FypI9y3dV2",
  "sha256": "abc123...",
  "mime_type": "application/x-dosexec",
  "size": 1048576,
  "src_ip": "10.0.0.5",
  "dst_ip": "93.184.216.34",
  "timestamp": 1711012345.123,
  "file_path": "/opt/zeek/logs/.../EXTRACTED_FypI9y3dV2"
}
```

#### `ml_scores` Collection

Stores static malware detection model output and SHAP explanation:

```json
{
  "sha256": "abc123...",
  "malware_prob": 0.92,
  "top_features": [
    { "name": "entropy", "value": 7.8, "contrib": 0.31 },
    { "name": "byte_hist_0xff", "value": 0.12, "contrib": 0.18 }
  ],
  "timestamp": 1711012350.456
}
```

#### `network_anomalies` Collection

Stores aggregated network features and anomaly scores per host (e.g., per IP per time window):

```json
{
  "ip": "10.0.0.5",
  "time_window_start": 1711012200,
  "time_window_end": 1711012500,
  "anomaly_score": 0.73,
  "features": {
    "num_connections": 320,
    "unique_dst_ips": 45,
    "avg_bytes_per_conn": 2048.5,
    "dns_entropy": 4.1,
    "rare_ports_count": 7
  }
}
```

#### `threat_intel` Collection

Stores external threat intelligence lookups for file hashes:

```json
{
  "sha256": "abc123...",
  "is_malicious_global": true,
  "sources": ["VirusTotal", "OTX"],
  "tags": ["ransomware", "trojan"],
  "first_seen": "2023-10-15T10:22:00Z"
}
```

#### `alerts` Collection

Final correlated alerts integrating file risk, network risk, and threat intelligence:

```json
{
  "ip": "10.0.0.5",
  "sha256": "abc123...",
  "threat_score": 0.89,
  "malware_prob": 0.92,
  "anomaly_score": 0.73,
  "intel_flag": true,
  "timestamp": 1711012360.000,
  "severity": "high"
}
```

---

## 6. Clean Architecture & Component Breakdown

The project is structured into **layers** and **components** to keep concerns separated and make the system easier to reason about and extend.

### 6.1 High-Level Layers

1. **Ingestion Layer**
   - Zeek traffic processing
   - File extraction
   - Log collection

2. **Big Data Processing Layer**
   - Spark batch jobs for log processing
   - Feature engineering for network behavior
   - Anomaly detection

3. **Analysis Layer**
   - Static malware detection (EMBER-based model)
   - Threat intelligence integration
   - SHAP explainability

4. **Correlation & Application Layer**
   - Threat scoring logic
   - Alert generation
   - Graph construction (network relationships)
   - API and dashboard

5. **Optional Streaming Layer (Extension)**
   - Kafka-based log streaming
   - Spark Streaming or consumer services

### 6.2 Component View

Below is a conceptual component diagram in text form:

```text
+-------------------------------------------------------------+
|                         Dashboard                           |
|  - Alerts view                                              |
|  - File analysis (ML + SHAP + intel)                        |
|  - Network anomaly view                                     |
|  - Graph visualization                                      |
+----------------------------+--------------------------------+
                             |
                       (REST / API)
                             |
+----------------------------v--------------------------------+
|                     Application Layer                       |
|  - Alert Correlation Service                                |
|  - Threat Scoring (file_risk, net_risk, intel)             |
|  - Graph Builder (host-to-host relationships)              |
+----------------------------+--------------------------------+
                             |
                     (DB: MongoDB collections)
                             |
+----------------------------v--------------------------------+
|                     Analysis Layer                          |
|  - Malware Classifier (LightGBM, EMBER)                     |
|  - Feature Extractor (files)                                |
|  - SHAP Explainer                                           |
|  - Threat Intel Client (VT, OTX, MalwareBazaar)             |
+----------------------------+--------------------------------+
                             |
                     (files, hashes, logs)
                             |
+----------------------------v--------------------------------+
|                   Big Data Processing Layer                 |
|  - Spark Log Loader                                         |
|  - Network Feature Engineering                              |
|  - Anomaly Detection (IsolationForest / KMeans)             |
+----------------------------+--------------------------------+
                             |
                     (Zeek logs, PCAP-derived)
                             |
+----------------------------v--------------------------------+
|                      Ingestion Layer                        |
|  - Zeek Packet Analyzer (PCAP)                              |
|  - Log Writers (conn, http, dns, files)                     |
|  - File Extractor                                           |
+-------------------------------------------------------------+
```

The **dependencies always go downward**:

- Dashboard depends on Application Layer.
- Application Layer depends on Analysis + Big Data.
- Analysis and Big Data depend on raw logs and files from Ingestion.

This structure avoids circular dependencies and allows each team member to work mostly within their component.

---

## 7. Detailed Process Flow

### 7.1 Offline Batch Mode (Core Project)

1. **Traffic Capture & Parsing**
   - PCAP files are run through Zeek.
   - Zeek produces `conn.log`, `http.log`, `dns.log`, `files.log` and extracted files.

2. **Ingestion into Storage**
   - A loader script parses Zeek logs and writes structured entries into MongoDB.
   - Extracted files are stored on disk and metadata is written to the `files` collection.

3. **Big Data Processing with Spark**
   - Spark reads logs (either directly from file system or via export from MongoDB).
   - Network features are computed per IP and per time window (e.g., 5 or 10 minutes).
   - An anomaly detection model assigns an `anomaly_score` to each host.
   - Results are written back into the `network_anomalies` collection.

4. **Static Malware Detection**
   - A LightGBM model is trained offline using EMBER precomputed features.
   - At detection time, for each extracted file:
     - Lightweight static features (entropy, size, byte histogram, strings statistics) are computed.
     - The feature vector is fed into the trained model.
     - The model returns `malware_prob` in [0, 1].
     - SHAP is used to compute feature contributions for interpretability.
   - The results are written to `ml_scores`.

5. **Threat Intelligence Enrichment**
   - For each new file hash (sha256), the system queries public threat intelligence APIs (where allowed).
   - Known-malicious hashes are marked, along with families/tags.
   - Results are stored in `threat_intel`.

6. **Threat Correlation**
   - The correlation service joins data from:
     - `files` (which host, which file)
     - `ml_scores` (malware_prob)
     - `network_anomalies` (anomaly_score for that host)
     - `threat_intel` (intel_flag, tags)
   - A threat score is computed, for example:

     ```text
     threat_score = 0.6 * malware_prob
                  + 0.25 * anomaly_score
                  + 0.15 * intel_flag
     ```

   - Alerts with high `threat_score` are written into the `alerts` collection.

7. **Visualization & Investigation**
   - The dashboard queries `alerts`, `files`, `ml_scores`, `network_anomalies`, and `threat_intel`.
   - Security analysts can:
     - See a ranked list of alerts by severity.
     - Inspect a file with its SHAP explanation and threat-intel results.
     - View suspicious hosts with their anomaly scores.
     - See the network graph with highlighted malicious nodes and edges.

---

## 8. Optional Real-Time Extension with Kafka

If time permits, a **lightweight streaming layer** can be added:

1. **Zeek Live Mode**
   - Zeek runs on a live network interface instead of static PCAPs.

2. **Log Forwarder → Kafka**
   - A simple agent tails Zeek logs and pushes each new line into Kafka topics such as:
     - `zeek_conn`
     - `zeek_dns`
     - `zeek_files`

3. **Streaming Consumers**
   - A Spark Streaming job or Python consumer ingests Kafka events.
   - For each batch of events:
     - Perform incremental feature updates.
     - Call the ML model for new files as they appear.
     - Update MongoDB collections in near real time.

4. **Real-Time Dashboard**
   - The dashboard periodically refreshes or subscribes to WebSocket updates.
   - Analysts see alerts and graph updates within seconds of events occurring.

This streaming layer is **not required** for the core project but can be presented as a clear extension path to demonstrate scalability and real-time potential.

---

## 9. Non-Functional Considerations

- **Scalability:** Spark and the architecture are designed to scale to larger log volumes if the infrastructure allows it.
- **Safety:** The system never executes malware; it only performs static analysis on file bytes and uses pre-extracted features for training.
- **Extensibility:** New data sources (e.g., email gateways, proxy logs) can be integrated by adding ingestion and mapping logic.
- **Explainability:** SHAP provides insight into why a file is classified as malicious, improving trust and aiding forensic analysis.

---

## 10. Summary

This project delivers a compact but realistic version of a modern **Network Detection and Response (NDR)** system that:

- Ingests and parses network traffic with Zeek.
- Processes large log volumes with Spark (Big Data requirement).
- Detects malicious files using a machine-learning model trained on EMBER.
- Assesses network behavior for anomalies.
- Correlates file-level and network-level risk into a unified threat score.
- Enriches alerts with external threat intelligence.
- Visualizes results in a dashboard, including a graph view of host relationships.
- Optionally supports a real-time streaming pipeline using Kafka.

The clean, layered architecture ensures that each module is independently understandable, testable, and replaceable, while the overall system closely resembles the structure of real-world enterprise security products.
